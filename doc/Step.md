# 步骤导向的产测思路

# Setup

+ [x] 检测软件完整度并弹窗
+ [x] 检测硬件是否连接并弹窗
+ [ ] 启动位于app.rs的线程后退出

# Loop/APP

## Step1

+ [ ] 工具是否连接并弹窗，采用Err机制，循环
  + [ ] 等待连接至KVM
    + 何为连接成功：数据密度不为0
    + 何为失败
  + [ ] 等待开机
  + [ ] 获取IP
  + [ ] 检测eMMC
  + [ ] 检测硬件版本
+ [ ] 下载产测
+ [ ] 打印身份贴纸

## Step2

+ [ ] 系统更新
+ [ ] HDMI检测
+ [ ] USB检测
+ [ ] ETH检测
+ [ ] WiFi检测
+ [ ] 交互检测
+ [ ] 其他接口检测

## Step3

+ [ ] 产测收尾
+ [ ] 打印不良贴纸





``` c
// Step 1 循环
loop {
    // usb_tool是否存在
    if (usb_tool_exit() != 1) {
        // 阻塞型弹窗建议重连，点击重新检测就continue
    }
    // 往后都是连接usb tool的状态
    if (kvm_uart_exit() != 1) {
    	timeout = 0;
        
        if (timeout > 10s) {
            // 阻塞型弹窗显示，点击重新检测/打印emmcddr不良
        }
        delay(10);
    }
}
```



+ 数据密度大：已连接并正在启动
+ 出现login: 输入账号：等待password：输入密码
+ 回车出现”:~#“进入系统：要开始一系列操作
+ 回车出现“AXERA-UBOOT=>”：进入BOOT环节，输入boot启动kernel



按顺序来说确实是一个顺序的关系：

1. 等待工具连接
2. 等待设备连接
3. 等待出现“AXERA-UBOOT=>”
4. 等待出现login，等待出现password
5. 等待出现”:~#“

但是可能会在任意时刻检测到，比如打印login打了一半这种情况，如何处理

1. 等待工具连接是必要的，而且需要时刻检测，如果下面任意函数抛出异常就需要回到开头，检测并弹窗
2. 下面需要用一个if状态机的思路做顺序型状态机：
3. 当然首先需要通过什么状态的检测：数据密度检测（检测的是当前的状态）
   1. 如果密度较大，则直接进入启动阶段（等待KVM启动阶段）进入
   2. 如果数据密度较小
      1. 缓存区出现login
      2. 缓冲区出现:~#
      3. 缓冲区出现AXERA-UBOOT=>
   3. 如果数据密度为0：发送回车判活：
      1. 缓存区出现login
      2. 缓冲区出现:~#
      3. 缓冲区出现AXERA-UBOOT=>
      4. 缓冲区无数据/数据密度还是0：未连接：倒计时10s还是没有连接就弹窗继续等待or打印贴纸+返回开头（好像不存在返回开头这一说）
   4. 所以说数据密度较小或者为0是一回事
4. 接下来就是进行中状态机（顺序while/if状态机），顺序如下：
   1. A：等待设备连接超时10s（进入打印贴纸B/重新检测A）
   2. B：打印不良贴纸（回到A）
   3. B：等待开机（直接进D）
   4. C：等待出现“AXERA-UBOOT=>”
   5. D：等待出现login，等待出现password
   6. E：等待出现”:~#“



