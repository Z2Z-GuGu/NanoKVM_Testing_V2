use std::sync::atomic::{AtomicBool, AtomicI32, Ordering};
use std::ptr;
use tauri::async_runtime::spawn;
use tauri::AppHandle;
use tokio::time::{sleep, Duration};
use winapi::shared::guiddef::GUID;
// use winapi::shared::winerror::{ERROR_INVALID_DATA, ERROR_NO_MORE_ITEMS};
use winapi::um::setupapi::{SetupDiGetClassDevsW, SetupDiEnumDeviceInfo, SetupDiGetDeviceRegistryPropertyW, SP_DEVINFO_DATA, DIGCF_PRESENT, SPDRP_HARDWAREID};
use rand::Rng;

// 暂时注释掉这些未使用的导入，以后实现真正的图像捕获时会用到
/*
use winapi::um::windowsx::{GetDC, ReleaseDC, GetBitmapBits, SetBitmapBits};
use winapi::um::wingdi::{CreateCompatibleDC, CreateDIBSection, DeleteDC, DeleteObject, SelectObject, BITMAPINFO, BITMAPINFOHEADER, BI_RGB, RGBQUAD};
use winapi::um::winuser::{EnumWindows, GetWindowTextW, IsWindowVisible, GetWindowLongPtrW, GWLP_HINSTANCE, SendMessageW, WM_CAP_DRIVER_CONNECT, WM_CAP_DRIVER_DISCONNECT, WM_CAP_GRAB_FRAME_NOSTOP, WM_CAP_SET_PREVIEW, WM_CAP_SET_PREVIEW_RATE};
use winapi::shared::minwindef::{LPARAM, TRUE, FALSE, UINT, WPARAM, LRESULT};
*/


// 日志控制：false=关闭详细日志，true=开启详细日志
const LOG_ENABLE: bool = false;

// 自定义日志函数
fn log(msg: &str) {
    if LOG_ENABLE {
        println!("[camera.rs] {}", msg);
    }
}

// 当前状态日志，始终显示
fn status_log(msg: &str) {
    println!("[camera.rs] {}", msg);
}

// USB摄像头筛选条件（可根据实际情况修改）
// 用户指定的摄像头VID和PID
const TARGET_VID: Option<u16> = Some(0x345f);
const TARGET_PID: Option<u16> = Some(0x2131);

// 摄像头状态枚举
#[derive(Debug, Clone, Copy)]
pub enum CameraStatus {
    Disconnected, // 未连接
    NoImage,      // 无画面（全黑）
    HasImage,     // 有画面
}

// 全局状态
static CAMERA_RUNNING: AtomicBool = AtomicBool::new(false);
// 使用AtomicI32存储状态，0: Disconnected, 1: NoImage, 2: HasImage
static CAMERA_STATUS: AtomicI32 = AtomicI32::new(0);

// 设置摄像头状态
fn set_camera_status(status: CameraStatus) {
    CAMERA_STATUS.store(status as i32, Ordering::Relaxed);
}

// 将宽字符串转换为Rust字符串
fn wchar_to_string(wchar: *const u16) -> String {
    let mut len = 0;
    unsafe {
        while *wchar.offset(len) != 0 {
            len += 1;
        }
    }
    let slice = unsafe { std::slice::from_raw_parts(wchar, len as usize) };
    String::from_utf16_lossy(slice)
}

// 使用Windows API检测USB设备
fn is_usb_device_present(target_vid: Option<u16>, target_pid: Option<u16>) -> bool {
    // 打开所有设备的信息集
    let h_dev_info = unsafe {
        SetupDiGetClassDevsW(
            ptr::null_mut(), // 所有设备类
            ptr::null_mut(), // 所有设备ID
            ptr::null_mut(), // 窗口句柄
            DIGCF_PRESENT | winapi::um::setupapi::DIGCF_ALLCLASSES // 所有已存在的设备
        )
    };

    if h_dev_info.is_null() {
        log("无法打开设备信息集");
        return false;
    }

    // 枚举设备
    let mut found = false;
    let mut dev_info_data: SP_DEVINFO_DATA = unsafe {
        std::mem::zeroed()
    };
    dev_info_data.cbSize = std::mem::size_of::<SP_DEVINFO_DATA>() as u32;

    let mut index = 0;
    while unsafe { SetupDiEnumDeviceInfo(h_dev_info, index, &mut dev_info_data) } != 0 {
        index += 1;

        // 获取硬件ID
        let mut buffer_size = 0;
        let mut property_type: u32 = 0;
        
        let result = unsafe {
            SetupDiGetDeviceRegistryPropertyW(
                h_dev_info,
                &mut dev_info_data as *mut SP_DEVINFO_DATA,
                SPDRP_HARDWAREID,
                &mut property_type,
                ptr::null_mut(),
                0,
                &mut buffer_size
            )
        };
        
        if result == 0 && buffer_size == 0 {
            continue;
        }

        if buffer_size == 0 {
            continue;
        }

        let mut buffer = Vec::with_capacity(buffer_size as usize);
        let result = unsafe {
            SetupDiGetDeviceRegistryPropertyW(
                h_dev_info,
                &mut dev_info_data as *mut SP_DEVINFO_DATA,
                SPDRP_HARDWAREID,
                &mut property_type,
                buffer.as_mut_ptr() as *mut u8,
                buffer_size,
                &mut buffer_size
            )
        };
        
        if result != 0 {
            // 确保缓冲区正确终止
            unsafe {
                buffer.set_len(buffer_size as usize);
            }

            // 解析硬件ID字符串
            let hardware_id = wchar_to_string(buffer.as_ptr() as *const u16);

            // 检查VID和PID
            if let Some(target_vid) = target_vid {
                if let Some(target_pid) = target_pid {
                    let vid_str = format!("VID_{:04X}", target_vid);
                    let pid_str = format!("PID_{:04X}", target_pid);
                    if hardware_id.contains(&vid_str) && hardware_id.contains(&pid_str) {
                        found = true;
                        break;
                    }
                }
            }
        }
    }

    // 关闭设备信息集
    unsafe {
        winapi::um::setupapi::SetupDiDestroyDeviceInfoList(h_dev_info);
    }

    found
}

// 检查图像是否为黑屏 - 暂时注释，因为我们还没有真正的图像捕获功能
/*
fn is_black_screen(image_data: &[u8], width: u32, height: u32) -> bool {
    // 检查参数有效性
    if image_data.is_empty() || width == 0 || height == 0 {
        log("图像数据无效");
        return true;
    }
    
    // 计算像素数
    let pixel_count = (width * height) as usize;
    
    // 检查数据长度是否符合预期 (每像素3字节: RGB)
    if image_data.len() < pixel_count * 3 {
        log(&format!("图像数据长度不足：实际={}, 预期={}", image_data.len(), pixel_count * 3));
        return true;
    }
    
    // 统计黑色像素数量
    let mut black_pixel_count = 0;
    
    // 遍历像素
    for i in 0..pixel_count {
        let index = i * 3;
        let r = image_data[index] as u32;
        let g = image_data[index + 1] as u32;
        let b = image_data[index + 2] as u32;
        
        // 计算亮度 (简单的RGB平均值)
        let brightness = (r + g + b) / 3;
        
        // 阈值：亮度低于10视为黑色像素
        if brightness < 10 {
            black_pixel_count += 1;
        }
    }
    
    // 计算黑色像素比例
    let black_ratio = black_pixel_count as f32 / pixel_count as f32;
    
    // 打印图像信息
    println!("[camera.rs] 图像信息 - 宽度: {}, 高度: {}, 总像素: {}, 黑色像素: {}, 黑色比例: {:.2}%", 
             width, height, pixel_count, black_pixel_count, black_ratio * 100.0);
    
    // 如果超过95%的像素是黑色，则视为黑屏
    black_ratio > 0.95
}
*/

// 尝试捕获摄像头图像并检测是否为黑屏
fn detect_camera_image() -> CameraStatus {
    // 这里使用一个简单的方法来模拟图像检测
    // 在实际应用中，这里应该实现真正的图像捕获和分析
    
    // 由于我们没有实际的图像捕获API，我们使用一个随机值来模拟
    // 80%的概率有图像，20%的概率黑屏
    let mut rng = rand::thread_rng();
    let is_black = rng.gen_bool(0.2);
    
    if is_black {
        CameraStatus::NoImage
    } else {
        CameraStatus::HasImage
    }
}

// 摄像头检测任务 - 实现真正的USB摄像头检测
async fn camera_detection_task(_app_handle: AppHandle) {
    log("启动摄像头检测任务");
    loop {
        // 检测目标USB摄像头设备是否存在
        let camera_found = is_usb_device_present(TARGET_VID, TARGET_PID);
        
        // 根据检测结果设置摄像头状态
        if camera_found {
            // 检测图像是否为黑屏
            let image_status = detect_camera_image();
            match image_status {
                CameraStatus::NoImage => {
                    status_log("检测到摄像头状态：NoImage");
                    set_camera_status(CameraStatus::NoImage);
                },
                CameraStatus::HasImage => {
                    status_log("检测到摄像头状态：HasImage");
                    set_camera_status(CameraStatus::HasImage);
                },
                _ => {}
            }
        } else {
            status_log("检测到摄像头状态：Disconnected");
            set_camera_status(CameraStatus::Disconnected);
        }
        
        // 每秒钟检查一次摄像头状态
        sleep(Duration::from_secs(1)).await;
    }
}

// 启动摄像头功能线程
pub fn spawn_camera_task(app_handle: AppHandle) {
    if CAMERA_RUNNING.swap(true, Ordering::Relaxed) {
        // 线程已经在运行
        log("摄像头线程已经在运行，忽略启动请求");
        return;
    }

    log("启动摄像头功能线程");
    spawn(async move {
        camera_detection_task(app_handle).await;
        // 线程结束时重置状态
        log("摄像头检测任务结束，重置状态");
        CAMERA_RUNNING.store(false, Ordering::Relaxed);
        set_camera_status(CameraStatus::Disconnected);
    });
}

// 查询摄像头状态的公共函数
pub fn get_camera_status() -> CameraStatus {
    let status_code = CAMERA_STATUS.load(Ordering::Relaxed);
    log(&format!("查询摄像头状态：{}", status_code));
    match status_code {
        0 => CameraStatus::Disconnected,
        1 => CameraStatus::NoImage,
        2 => CameraStatus::HasImage,
        _ => CameraStatus::Disconnected, // 默认状态
    }
}
