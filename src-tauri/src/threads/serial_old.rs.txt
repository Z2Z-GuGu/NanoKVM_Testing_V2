use std::sync::atomic::{AtomicPtr, Ordering};
use std::sync::LazyLock;
use tokio::time::{sleep, Duration};
use serialport::{SerialPortType, DataBits, Parity, StopBits, FlowControl};
use tauri::async_runtime::spawn;
use tauri::{AppHandle, Emitter};
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio_serial::SerialStream;

// 日志控制：0=开启日志，1=关闭日志
const LOG_DISABLE: u8 = 0;

// 自定义日志函数
fn log(msg: &str) {
    if LOG_DISABLE == 0 {
        println!("{}", msg);
    }
}

// USB设备筛选条件
const TARGET_VID: u16 = 0x1a86;
const TARGET_PID: u16 = 0x55d3;

// 串口配置
const BAUD_RATE: u32 = 115200;

// 全局串口状态
static SERIAL_PORT: LazyLock<AtomicPtr<Option<SerialStream>>> = LazyLock::new(|| {
    AtomicPtr::new(Box::into_raw(Box::new(None)))
});

// 发送消息到前端
fn send_to_frontend(app_handle: &AppHandle, msg: &str) {
    app_handle.emit("terminal-output", msg).unwrap();
}

// 安全更新串口状态
fn update_serial_port(port: Option<SerialStream>) {
    let old_ptr = SERIAL_PORT.swap(Box::into_raw(Box::new(port)), Ordering::Relaxed);
    unsafe { let _ = Box::from_raw(old_ptr); };
}

// 检查目标设备是否存在
async fn is_device_present() -> bool {
    if let Ok(ports) = serialport::available_ports() {
        for port_info in ports {
            if let SerialPortType::UsbPort(usb_info) = port_info.port_type {
                if usb_info.vid == TARGET_VID && usb_info.pid == TARGET_PID {
                    return true;
                }
            }
        }
    }
    false
}

// 第一部分：串口扫描&连接&断开检测&重连线程
async fn serial_scan_and_connect_task(app_handle: AppHandle) {
    log("启动串口扫描&连接&断开检测&重连线程");
    let mut is_connected = false;

    loop {
        // 检查目标设备是否存在
        if is_device_present().await {
            // 设备存在但尚未连接
            if !is_connected {
                log("发现目标设备，正在尝试连接...");
                
                // 扫描并连接串口设备
                if let Ok(ports) = serialport::available_ports() {
                    for port_info in ports {
                        if let SerialPortType::UsbPort(usb_info) = port_info.port_type {
                            if usb_info.vid == TARGET_VID && usb_info.pid == TARGET_PID {
                                // 配置并打开串口
                                let builder = serialport::new(&port_info.port_name, BAUD_RATE)
                                    .data_bits(DataBits::Eight)
                                    .parity(Parity::None)
                                    .stop_bits(StopBits::One)
                                    .flow_control(FlowControl::None);

                                if let Ok(port) = SerialStream::open(&builder) {
                                    update_serial_port(Some(port));
                                    send_to_frontend(&app_handle, "[connected]\n");
                                    log("成功连接到目标串口设备");
                                    is_connected = true;
                                    
                                    // 连接成功后自动启动接收线程

                                    let app_handle_for_receive = app_handle.clone();
                                    
                                    spawn(async move {
                                        // 接收数据，当接收线程退出时（无论是正常退出还是错误退出）
                                        // 都会执行后续的重连逻辑
                                        receive_data(&app_handle_for_receive).await;
                                        
                                        // 接收线程退出，检查是否需要重连
                                        log("接收线程已退出，检查连接状态...");
                                        let port_ptr = SERIAL_PORT.load(Ordering::Relaxed);
                                        if unsafe { &mut *port_ptr }.is_none() {
                                            // 串口已关闭，需要重新连接
                                            log("串口已断开，准备重新连接...");
                                        }
                                    });
                                    break;
                                }
                            }
                        }
                    }
                }
            } else {
                // 设备存在且已连接，检查当前串口状态
                let port_ptr = SERIAL_PORT.load(Ordering::Relaxed);
                if unsafe { &mut *port_ptr }.is_none() {
                    // 串口已断开但设备仍存在，重新连接
                    log("串口已断开但设备仍存在，准备重新连接...");
                    is_connected = false;
                }
            }
        } else {
            // 设备不存在且当前已连接
            if is_connected {
                log("目标设备已断开连接");
                update_serial_port(None);
                send_to_frontend(&app_handle, "[disconnected]\n");
                is_connected = false;
            }
        }
        
        // 设备存在时降低扫描频率，不存在时增加扫描频率
        sleep(if is_connected { Duration::from_secs(5) } else { Duration::from_millis(500) }).await;
    }
}

// 第二部分：串口接收线程（只要接收到数据就print出来）
async fn receive_data(app_handle: &AppHandle) {
    log("启动串口数据接收线程");
    
    loop {
        let mut buffer = vec![0; 1024];
        
        // 安全地获取并使用串口
        let port_ptr = SERIAL_PORT.load(Ordering::Relaxed);
        if let Some(port) = unsafe { &mut *port_ptr }.as_mut() {
            match port.read(&mut buffer).await {
                Ok(n) if n > 0 => {
                    // 将接收到的数据转换为字符串并发送到前端
                    let data = String::from_utf8_lossy(&buffer[..n]);
                    log(&format!("接收到数据: {}", data.trim()));
                    send_to_frontend(app_handle, &data);
                    // 同时在控制台print出来
                    println!("Serial Received: {}", data.trim());
                },
                Ok(_) => {
                    // 读取到0字节，视为正常现象
                    log("读取到0字节数据（正常现象）");
                },
                Err(e) => {
                    // 读取错误，记录并退出接收线程
                    log(&format!("读取数据时发生错误: {:?}", e));
                    // 检查是否是权限错误或其他严重错误
                    if let std::io::ErrorKind::PermissionDenied = e.kind() {
                        log("检测到权限错误，认为连接已断开");
                        // 关闭串口
                        update_serial_port(None);
                        send_to_frontend(app_handle, "[disconnected]\n");
                        break;
                    }
                }
            }
        } else {
            // 串口未连接，退出接收线程
            log("串口已断开连接，退出接收线程");
            break;
        }
        
        sleep(Duration::from_millis(10)).await;
    }
}

// 第三部分：串口发送函数
pub async fn send_data(data: &str) -> Result<(), Box<dyn std::error::Error>> {
    log(&format!("尝试发送数据: {}", data.trim()));
    let port_ptr = SERIAL_PORT.load(Ordering::Relaxed);
    if let Some(port) = unsafe { &mut *port_ptr }.as_mut() {
        port.write_all(data.as_bytes()).await?;
        log("数据发送成功");
        Ok(())
    } else {
        log("串口未连接，无法发送数据");
        Ok(())
    }
}

// 启动串口功能线程
pub fn spawn_serial_task(app_handle: AppHandle) {
    log("启动串口功能");
    
    // 克隆app_handle以便在多个任务中使用
    let app_handle_clone = app_handle.clone();
    
    // 先启动第一个线程：串口扫描&连接&断开检测&重连线程
    spawn(async move {
        serial_scan_and_connect_task(app_handle_clone).await;
    });
    
    // 启动发送测试任务
    spawn(async move {
        log("启动串口发送测试任务");
        let mut test_count = 0;
        loop {
            // 检查串口是否连接
            let port_ptr = SERIAL_PORT.load(Ordering::Relaxed);
            if let Some(_) = unsafe { &mut *port_ptr }.as_mut() {
                // 发送测试字符
                test_count += 1;
                let test_data = format!("Test {}: Hello, Serial!\n", test_count);
                if let Ok(_) = send_data(&test_data).await {
                    log(&format!("发送测试数据 #{} 成功", test_count));
                } else {
                    log(&format!("发送测试数据 #{} 失败", test_count));
                }
                // 每2秒发送一次测试数据
                sleep(Duration::from_secs(2)).await;
            } else {
                // 串口未连接时，减少检查频率
                sleep(Duration::from_secs(1)).await;
            }
        }
    });
}
